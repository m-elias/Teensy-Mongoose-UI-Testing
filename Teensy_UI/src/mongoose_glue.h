// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

#ifndef MONGOOSE_GLUE_H
#define MONGOOSE_GLUE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "mongoose.h"

#define WIZARD_ENABLE_HTTP 1
#define WIZARD_ENABLE_HTTPS 0
#define WIZARD_ENABLE_HTTP_UI 1
#define WIZARD_ENABLE_HTTP_UI_LOGIN 0

#define WIZARD_ENABLE_WEBSOCKET 1

#define WIZARD_ENABLE_MQTT 0
#define WIZARD_MQTT_URL ""

#define WIZARD_ENABLE_SNTP 0  // Enable time sync.
#define WIZARD_SNTP_TYPE 0    // 0: default Google, 1: DHCP, 2: custom
#define WIZARD_SNTP_URL "udp://time.google.com:123"  // Custom SNTP server URL
#define WIZARD_SNTP_INTERVAL_SECONDS 3600            // Frequency of SNTP syncs

#define WIZARD_DNS_TYPE 0  // 0: default Google, 1: DHCP, 2: custom
#define WIZARD_DNS_URL "udp://8.8.8.8:53"  // Custom DNS server URL
#define WIZARD_CAPTIVE_PORTAL 0

#define WIZARD_ENABLE_MODBUS 0
#define WIZARD_MODBUS_PORT 502

#ifndef WIZARD_REBOOT_TIMEOUT_MS
#define WIZARD_REBOOT_TIMEOUT_MS 500
#endif

void mongoose_init(void);    // Initialise Mongoose
void mongoose_poll(void);    // Poll Mongoose
extern struct mg_mgr g_mgr;  // Mongoose event manager

void mongoose_set_http_handlers(const char *name, ...);
void mongoose_add_ws_handler(unsigned ms, void (*)(struct mg_connection *));

#define run_mongoose() \
  do {                 \
    mongoose_init();   \
    for (;;) {         \
      mongoose_poll(); \
    }                  \
  } while (0)

#if WIZARD_ENABLE_MQTT
void glue_lock_init(void);  // Initialise global Mongoose mutex
void glue_lock(void);       // Lock global Mongoose mutex
void glue_unlock(void);     // Unlock global Mongoose mutex
#else
#define glue_lock_init()
#define glue_lock()
#define glue_unlock()
#endif

// Increment device change state counter - trigger UI refresh
void glue_update_state(void);

// Firmware Glue

void glue_start_reboot(struct mg_str);  // Start an action
bool glue_check_reboot(void);  // Check if action is still in progress

void glue_start_dec_work_thres(struct mg_str);  // Start an action
bool glue_check_dec_work_thres(void);  // Check if action is still in progress

void glue_start_inc_work_thres(struct mg_str);  // Start an action
bool glue_check_inc_work_thres(void);  // Check if action is still in progress

void glue_start_set_work_thres(struct mg_str);  // Start an action
bool glue_check_set_work_thres(void);  // Check if action is still in progress

void glue_start_set_work_digital(struct mg_str);  // Start an action
bool glue_check_set_work_digital(void);  // Check if action is still in progress

void glue_start_cycleOutput(struct mg_str);  // Start an action
bool glue_check_cycleOutput(void);  // Check if action is still in progress

void *glue_ota_begin_firmware_update(char *file_name, size_t total_size);
bool glue_ota_end_firmware_update(void *context);
bool glue_ota_write_firmware_update(void *context, void *buf, size_t len);

struct comms {
  char gps1Baud[10];
  int gps1State;
  char gps2Baud[10];
  int gps2State;
  bool gpsPass;
  char gpsSync[15];
  int imuState;
  char rs232Baud[10];
  int rs232State;
  char nmeaSource[10];
  char rtkBaud[10];
  int rtkState;  // does not parse data, only detects that there is some data
  char keyaBaud[10];  // if DISABLED is selected, set [device]State = 4
  int keyaState;  // -1: Show all elements, 0: Timed Out, 1: Active, 2: Missed Updates, 3: Undetected, 4: Disabled by User, 5: Disabled by Hardware (hidden)
  char keyaPort[15];
  bool esp32BridgeEnabled;
  char esp32Baud[10];
  int esp32State;
  char esp32Runtime[20];
  int esp32NumClients;
  char esp32SSID[24];
  char esp32PW[24];
  int ntripState;  // does not parse data, only detects that there is some data
};
void glue_get_comms(struct comms *);
void glue_set_comms(struct comms *);

struct inputs {
  int workInput;
  int workThres;
  char workHystStr[3];
  int workHystVal;
  bool workInvert;
  int workState;
  char steerSelection[10];
  int steerInput;
  bool steerInvert;
  int steerState;  // -1: Show all elements, 0: Timed Out, 1: Active, 2: Missed Updates, 3: Undetected, 4: Disabled by User, 5: Disabled by Hardware (hidden)
  int kickoutInput;
  bool kickoutInvert;
  int kickoutState;
  int kickoutStateHist;
  char kickoutModeStr[30];
};
void glue_get_inputs(struct inputs *);
void glue_set_inputs(struct inputs *);

void glue_reply_inputsKickoutModeList(struct mg_connection *, struct mg_http_message *);
struct outputs {
  char drv8701PwmFreq[20];
  char outputsModeStr[20];
  int sec1State;
  int sec2State;
  int sec3State;
  int sec4State;
  int sec5State;
  int sec6State;
  bool sec1Invert;
  bool sec2Invert;
  bool sec3Invert;
  bool sec4Invert;
  bool sec5Invert;
  bool sec6Invert;
  int sec1Output;
  int sec2Output;
  int sec3Output;
  int sec4Output;
  int sec5Output;
  int sec6Output;
  char sec1PinsStr[6];
  char sec2PinsStr[6];
  char sec3PinsStr[6];
  char sec4PinsStr[6];
  char sec5PinsStr[6];
  char sec6PinsStr[6];
};
void glue_get_outputs(struct outputs *);
void glue_set_outputs(struct outputs *);

void glue_reply_outputsPwmFreqList(struct mg_connection *, struct mg_http_message *);
struct misc {
  int rgbBrightness;
  bool update;
  char fversion[50];
};
void glue_get_misc(struct misc *);
void glue_set_misc(struct misc *);


#ifdef __cplusplus
}
#endif
#endif  // MONGOOSE_GLUE_H
