// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

// Default mock implementation of the API callbacks

#include "mongoose_glue.h"
static uint64_t s_action_timeout_reboot;  // Time when reboot ends
bool glue_check_reboot(void) {
  return s_action_timeout_reboot > mg_now(); // Return true if reboot is in progress
}
void glue_start_reboot(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_reboot = mg_now() + 1000; // Start reboot, finish after 1 second
}

static uint64_t s_action_timeout_dec_work_thres;  // Time when dec_work_thres ends
bool glue_check_dec_work_thres(void) {
  return s_action_timeout_dec_work_thres > mg_now(); // Return true if dec_work_thres is in progress
}
void glue_start_dec_work_thres(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_dec_work_thres = mg_now() + 1000; // Start dec_work_thres, finish after 1 second
}

static uint64_t s_action_timeout_inc_work_thres;  // Time when inc_work_thres ends
bool glue_check_inc_work_thres(void) {
  return s_action_timeout_inc_work_thres > mg_now(); // Return true if inc_work_thres is in progress
}
void glue_start_inc_work_thres(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_inc_work_thres = mg_now() + 1000; // Start inc_work_thres, finish after 1 second
}

static uint64_t s_action_timeout_set_work_thres;  // Time when set_work_thres ends
bool glue_check_set_work_thres(void) {
  return s_action_timeout_set_work_thres > mg_now(); // Return true if set_work_thres is in progress
}
void glue_start_set_work_thres(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_set_work_thres = mg_now() + 1000; // Start set_work_thres, finish after 1 second
}

static uint64_t s_action_timeout_set_work_digital;  // Time when set_work_digital ends
bool glue_check_set_work_digital(void) {
  return s_action_timeout_set_work_digital > mg_now(); // Return true if set_work_digital is in progress
}
void glue_start_set_work_digital(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_set_work_digital = mg_now() + 1000; // Start set_work_digital, finish after 1 second
}

static uint64_t s_action_timeout_cycleOutput;  // Time when cycleOutput ends
bool glue_check_cycleOutput(void) {
  return s_action_timeout_cycleOutput > mg_now(); // Return true if cycleOutput is in progress
}
void glue_start_cycleOutput(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_cycleOutput = mg_now() + 1000; // Start cycleOutput, finish after 1 second
}

void *glue_ota_begin_firmware_update(char *file_name, size_t total_size) {
  bool ok = mg_ota_begin(total_size);
  MG_DEBUG(("%s size %lu, ok: %d", file_name, total_size, ok));
  return ok ? (void *) 1 : NULL;
}
bool glue_ota_end_firmware_update(void *context) {
  mg_timer_add(&g_mgr, 500, 0, (void (*)(void *)) mg_ota_end, context);
  return true;
}
bool glue_ota_write_firmware_update(void *context, void *buf, size_t len) {
  MG_DEBUG(("ctx: %p %p/%lu", context, buf, len));
  return mg_ota_write(buf, len);
}

static struct comms s_comms = {"921600", -1, "921600", -1, false, "60ms - F9P", -1, "57600", -1, "AgOpenGPS", "115200", -1, "250000", -1, "1 - Pin 16/17", false, "460800", -1, "0d 0h 0m 0s", 12, "**SSID**", "**PW**", -1};
void glue_get_comms(struct comms *data) {
  *data = s_comms;  // Sync with your device
}
void glue_set_comms(struct comms *data) {
  s_comms = *data; // Sync with your device
}

static struct inputs s_inputs = {50, 50, "18", 18, true, -1, "*from AOG*", -1, true, -1, -1, true, -1, -1, "1 - AOG Setting (default)"};
void glue_get_inputs(struct inputs *data) {
  *data = s_inputs;  // Sync with your device
}
void glue_set_inputs(struct inputs *data) {
  s_inputs = *data; // Sync with your device
}

void glue_reply_inputsKickoutModeList(struct mg_connection *c, struct mg_http_message *hm) {
  const char *headers = "Cache-Control: no-cache\r\n" "Content-Type: application/json\r\n";
  const char *value = "[\"1 - AOG Setting (default)\",\"2 - Quadrature Encoder\",\"3 - JD Variable Duty Encoder\",\"4 - WAS-PWM Ratio\",\"5 - Encoder Speed\"]";
  (void) hm;
  mg_http_reply(c, 200, headers, "%s\n", value);
}
static struct outputs s_outputs = {"shoutld change", "1 - Single Ended", 0, 1, 4, 4, 0, 1, false, true, false, false, false, false, 0, 0, -1, -1, 0, 1, "7", "8", "9", "10", "11", "12"};
void glue_get_outputs(struct outputs *data) {
  *data = s_outputs;  // Sync with your device
}
void glue_set_outputs(struct outputs *data) {
  s_outputs = *data; // Sync with your device
}

void glue_reply_outputsPwmFreqList(struct mg_connection *c, struct mg_http_message *hm) {
  const char *headers = "Cache-Control: no-cache\r\n" "Content-Type: application/json\r\n";
  const char *value = "[\"122 hz - Valve\",\"490 hz\",\"3921 hz\"]";
  (void) hm;
  mg_http_reply(c, 200, headers, "%s\n", value);
}
static struct misc s_misc = {75, false, "AiO NG v6"};
void glue_get_misc(struct misc *data) {
  *data = s_misc;  // Sync with your device
}
void glue_set_misc(struct misc *data) {
  s_misc = *data; // Sync with your device
}
